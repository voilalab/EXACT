

from tqdm import tqdm
import numpy as np
import matplotlib.pyplot as plt
import time
import prox_tv


# parameters for the scanning setup
nx, ny = 25, 25 # dimension of image
scanner_rad = 30 # radius from center to gantry (cm)
image_side = 10 # length of one side of square image array (cm)
theta = 4*np.arcsin(image_side/(np.sqrt(2.0)*scanner_rad)) # angle of the beam (radians)
phantom_rad = 5 # radius of the circular phantom (cm)
nk = nx*ny  # number of pixels
energies = np.arange(1,100,2); ni = len(energies); energy_binwidth=2 # discretizing photon energy (keV)
nw = 3 # number of energy windows in detector
nm = 1 # number of materials (we focus on the single-material setting)


# parameters for optimization with ADMM
sig_grid = np.array([100])
nsig = len(sig_grid)
div_by_zero_thresh = 1e-8 # avoid dividing by zero with step size matrices
niter_newton = 10 # Newton-Raphson algorithm for solving convex subproblem


# parameters for optimization with monotone operator or extragradient method
stepsizes = np.array([2e-8]) 
nstepsize = len(stepsizes)
polyakstepsizes = np.array([1])
npolyakstepsize = len(polyakstepsizes)
gdstepsizes = np.array([5e-9])
ngdstepsize = len(gdstepsizes)

# generate phantom - a disk of pmma of radius phantom_rad,
# with four smaller disks of partial pmma
# centered at the points (+/- phantom_rad*0.4, +/- phantom_rad*0.4) with radius phantom_rad*0.25
x_true = np.zeros((nx,ny,nm))
materials_in_ball = np.array([[0,1,0],[0.9,0.1,0],[0.2,0.8,0],[0.7,0.3,0]])  # Material combinations for single-material model; only the PMMA values are actually used
materials_in_ball = materials_in_ball[:, 0:nm]
ball_centers = np.array([[phantom_rad*0.4,phantom_rad*0.4],[phantom_rad*0.4,-phantom_rad*0.4],\
                         [-phantom_rad*0.4,-phantom_rad*0.4],[-phantom_rad*0.4,phantom_rad*0.4]])
ball_radii = np.array([phantom_rad*0.25,phantom_rad*0.25,phantom_rad*0.25,phantom_rad*0.25])
for ix in range(nx):
    for iy in range(ny):
        x_coord = (-image_side/2) + (image_side*ix)/float(nx)
        y_coord = (-image_side/2) + (image_side*iy)/float(ny)
        if x_coord**2+y_coord**2 <= phantom_rad**2:
            x_true[ix,iy,0] = 1
            for iball in range(len(ball_radii)):
                if (x_coord-ball_centers[iball,0])**2 + (y_coord-ball_centers[iball,1])**2 <\
                        ball_radii[iball]**2:
                    x_true[ix,iy] = materials_in_ball[iball]


# create source/detector response S

# create window functions with linear blur
blur_prop = 0.1 # width of blur on each side as a function of width of total range
blur_width = blur_prop*(energies.max() - energies.min())/nw
w_breaks = np.r_[1.,50.,70.,99.]
w_breaks[0] -= blur_width
w_breaks[-1] += blur_width
w_shape = np.zeros((nw,ni))

spectrum = np.c_[np.arange(10,102,2), np.array([0.00368,0.00355,0.00459,0.0077,0.01474,\
  0.02249,0.02691,0.03264,0.03889,0.04088,0.04307,0.04396,0.04428,0.04315,0.04284,0.04095,\
  0.03944,0.03795,0.03627,0.0346,0.03267,0.03113,0.02894,0.02733,0.02647,0.05175,0.02204,\
  0.02084,0.01866,0.02607,0.01502,0.01218,0.01121,0.01026,0.0092,0.00854,0.00749,0.00682,\
  0.00579,0.00486,0.00417,0.00324,0.0024,0.00168,0.00114,0.00017])]
# These values are taken from the following paper:
# "Diagnostic x-ray spectra: A comparison of spectra generated by
#     different computational methods with a measured spectrum"
# Bhat et al, Med. Phys. 25(1), 1998
# (Table I)

spectrum = np.exp(np.interp(energies, spectrum[:,0], np.log(spectrum[:,1]), \
                            left = -np.inf, right = -np.inf))
spectrum /= spectrum.sum()

for w_ in range(nw):
    w_shape[w_] = \
      (1 - np.minimum(np.maximum((w_breaks[w_] + blur_width - energies)/2/blur_width,0),1)\
       - np.minimum(np.maximum((energies - w_breaks[w_+1] + blur_width)/2/blur_width,0),1))\
        * spectrum

def get_S(total_intensity, nl):
    S = total_intensity * np.outer(w_shape,np.ones(nl)).reshape((nw,ni,nl)).transpose((0,2,1))
    # constant across rays l_=1,..,nl i.e. no differences between different detector cells
    return S

def plot_detector_spectra(total_intensity, nl):
    S = get_S(total_intensity=total_intensity, nl=nl)
    plt.figure(figsize=(10, 3))
    plt.subplot(121)
    plt.plot(energies,spectrum/energy_binwidth,label='X-ray beam') # rescaling to obtain a density
    plt.legend(loc='upper right')
    plt.xlabel('Energy (keV)')
    plt.ylabel('Photon Spectral Density')
    plt.subplot(122)
    plt.plot(energies,S[0,0]/total_intensity/energy_binwidth,label='Window 1')
    plt.plot(energies,S[1,0]/total_intensity/energy_binwidth,label='Window 2')
    plt.plot(energies,S[2,0]/total_intensity/energy_binwidth,label='Window 3')
    plt.legend(loc='upper right')
    plt.xlabel('Energy (keV)')
    plt.yticks([])
    plt.tight_layout()
    plt.savefig('detector_spectra.jpg')
    plt.close()


# attenuation coefficients scraped from NIST
# and interpolated on the log scale to the predefined energy levels

# sources for density:
# PMMA, air, water: https://physics.nist.gov/PhysRefData/XrayMassCoef/tab2.html
# aluminum & gadolinium: https://physics.nist.gov/PhysRefData/XrayMassCoef/tab1.html

# sources for mu_per_density (a.k.a mass attenuation coefficient):
# PMMA: https://physics.nist.gov/PhysRefData/XrayMassCoef/ComTab/pmma.html
# aluminum: https://physics.nist.gov/PhysRefData/XrayMassCoef/ElemTab/z13.html
# gadolinium: https://physics.nist.gov/PhysRefData/XrayMassCoef/ElemTab/z64.html
# water: https://physics.nist.gov/PhysRefData/XrayMassCoef/ComTab/water.html
# air: https://physics.nist.gov/PhysRefData/XrayMassCoef/ComTab/air.html
# mu is the linear attenuation coefficient (1/cm)

density_PMMA = 1.190
mu_per_density_PMMA = np.array([\
        2.79400000e+03, 1.23600000e+02, 2.68100000e+01, 1.00166012e+01,\
        4.66908535e+00, 2.68607749e+00, 1.71970094e+00, 1.10100000e+00,\
        8.46931890e-01, 6.51492848e-01, 5.36313998e-01, 4.72472923e-01,\
        4.16231282e-01, 3.66684463e-01, 3.23035537e-01, 2.95571846e-01,\
        2.80886455e-01, 2.66930703e-01, 2.53668338e-01, 2.41064909e-01,\
        2.32082263e-01, 2.26355019e-01, 2.20769110e-01, 2.15321048e-01,\
        2.10007431e-01, 2.05848821e-01, 2.02781180e-01, 1.99759255e-01,\
        1.96782364e-01, 1.93849835e-01, 1.91495742e-01, 1.89699956e-01,\
        1.87921010e-01, 1.86158746e-01, 1.84413009e-01, 1.82683642e-01,\
        1.80970493e-01, 1.79273409e-01, 1.77592240e-01, 1.75926836e-01,\
        1.74532885e-01, 1.73404160e-01, 1.72282734e-01, 1.71168560e-01,\
        1.70061593e-01, 1.68961784e-01, 1.67869087e-01, 1.66783457e-01,\
        1.65704848e-01, 1.64633215e-01])
mu_PMMA = mu_per_density_PMMA * density_PMMA

density_aluminum = 2.699
mu_per_density_aluminum = np.array([\
        1.18500000e+03, 7.88000000e+02, 1.93400000e+02, 7.61777461e+01,\
        3.63339497e+01, 2.06617294e+01, 1.28204546e+01, 7.95500000e+00,\
        5.68928879e+00, 4.06888837e+00, 3.07784762e+00, 2.46247597e+00,\
        1.97013908e+00, 1.57623792e+00, 1.26109167e+00, 1.05329794e+00,\
        9.18407688e-01, 8.00792108e-01, 6.98238929e-01, 6.08819189e-01,\
        5.44319639e-01, 4.99000607e-01, 4.57454752e-01, 4.19367927e-01,\
        3.84452140e-01, 3.57884146e-01, 3.38295129e-01, 3.19778329e-01,\
        3.02275059e-01, 2.85729841e-01, 2.73395705e-01, 2.64795487e-01,\
        2.56465807e-01, 2.48398154e-01, 2.40584285e-01, 2.33016217e-01,\
        2.25686218e-01, 2.18586800e-01, 2.11710708e-01, 2.05050917e-01,\
        2.00100689e-01, 1.96744874e-01, 1.93445339e-01, 1.90201138e-01,\
        1.87011345e-01, 1.83875047e-01, 1.80791347e-01, 1.77759362e-01,\
        1.74778226e-01, 1.71847085e-01])
mu_aluminum = mu_per_density_aluminum * density_aluminum

density_gadolinium = 7.900
mu_per_density_gadolinium = np.array([\
        2291.        , 1292.        ,  365.3       ,  156.89085391,\
        353.5249706 ,  217.87728117,  142.61431975,   93.35      ,\
         68.86248306,   50.79851713,   39.16968525,   31.57038073,\
         25.44541609,   20.50875489,   16.52985455,   13.74995004,\
         11.80417281,   10.13374561,    8.6997032 ,    7.46859441,\
          6.52744112,    5.8078675 ,    5.16761841,    4.59794925,\
          4.09107942,   17.98139263,   16.35911816,   14.88320467,\
         13.54044755,   12.31883346,   11.31984357,   10.50619708,\
          9.75103377,    9.05015002,    8.39964431,    7.79589558,\
          7.23554304,    6.71546746,    6.23277381,    5.78477517,\
          5.41272081,    5.10585873,    4.81639351,    4.54333887,\
          4.28576446,    4.04279264,    3.81359557,    3.59739231,\
          3.39344622,    3.20106238])
mu_gadolinium = mu_per_density_gadolinium * density_gadolinium

density_air = 1.205e-3
mu_per_density_air = np.array([\
        3.60600000e+03, 1.62500000e+02, 4.02700000e+01, 1.52397707e+01,\
        7.12709759e+00, 4.06440217e+00, 2.56123898e+00, 1.61400000e+00,\
        1.20534571e+00, 9.00160026e-01, 7.18964053e-01, 6.14149339e-01,\
        5.24615116e-01, 4.48133707e-01, 3.82802198e-01, 3.41518854e-01,\
        3.18220679e-01, 2.96511888e-01, 2.76284056e-01, 2.57436153e-01,\
        2.44118160e-01, 2.35584914e-01, 2.27349951e-01, 2.19402844e-01,\
        2.11733531e-01, 2.05852966e-01, 2.01625156e-01, 1.97484177e-01,\
        1.93428245e-01, 1.89455614e-01, 1.86372898e-01, 1.84138980e-01,\
        1.81931839e-01, 1.79751153e-01, 1.77596605e-01, 1.75467882e-01,\
        1.73364674e-01, 1.71286676e-01, 1.69233586e-01, 1.67205105e-01,\
        1.65573031e-01, 1.64326181e-01, 1.63088720e-01, 1.61860578e-01,\
        1.60641684e-01, 1.59431969e-01, 1.58231364e-01, 1.57039800e-01,\
        1.55857209e-01, 1.54683524e-01])
mu_air = mu_per_density_air * density_air

density_water = 1.0
mu_per_density_water = np.array([\
        4.07800000e+03, 1.92900000e+02, 4.25800000e+01, 1.59848929e+01,\
        7.43382338e+00, 4.22683957e+00, 2.65922970e+00, 1.67300000e+00,\
        1.25142770e+00, 9.36085650e-01, 7.49749195e-01, 6.42994154e-01,\
        5.51439716e-01, 4.72921500e-01, 4.05583310e-01, 3.63174287e-01,\
        3.39542475e-01, 3.17448390e-01, 2.96791970e-01, 2.77479666e-01,\
        2.63840861e-01, 2.55143683e-01, 2.46733196e-01, 2.38599950e-01,\
        2.30734807e-01, 2.24707041e-01, 2.20384502e-01, 2.16145113e-01,\
        2.11987275e-01, 2.07909417e-01, 2.04728822e-01, 2.02406413e-01,\
        2.00110349e-01, 1.97840331e-01, 1.95596064e-01, 1.93377255e-01,\
        1.91183617e-01, 1.89014862e-01, 1.86870710e-01, 1.84750880e-01,\
        1.83027090e-01, 1.81688655e-01, 1.80360009e-01, 1.79041078e-01,\
        1.77731792e-01, 1.76432081e-01, 1.75141874e-01, 1.73861103e-01,\
        1.72589697e-01, 1.71327589e-01])
mu_water = mu_per_density_water * density_water


mu = np.c_[mu_PMMA,mu_aluminum,mu_gadolinium].T

mu = mu[0:nm,:]  # only use PMMA for our single-material phantom, since nm=1



def convert_to_HU(image):
    # Assume image contains the amount of PMMA at each pixel, since we are reconstructing assuming a single material that is PMMA
    # integrate over the source spectrum
    running_sum = 0
    for energy_index in range(ni):
        running_sum += spectrum[energy_index] * 1000 * (mu_PMMA[energy_index]*image - mu_water[energy_index]) / (mu_water[energy_index] - mu_air[energy_index])
    return running_sum

def plot_x(x_list, title=None, filename=None, use_HU=True):
    vmin = np.ones(3)*np.inf
    vmax = np.ones(3)*-np.inf
    for x in x_list:
        vmin = np.minimum(vmin,x.min((0,1)))
        vmax = np.maximum(vmax,x.max((0,1)))
    for i in range(len(x_list)):
        plt.figure()
        if nm == 1:
            if use_HU:
                plt.imshow(convert_to_HU(x_list[i]), cmap='gray')
            else:
                plt.imshow(x_list[i], cmap='gray')
            plt.xticks([])
            plt.yticks([])
            plt.colorbar()
            plt.tight_layout()
        else:
            plt.subplot(131)
            plt.imshow(x_list[i][:,:,0],vmin=vmin[0],vmax=vmax[0], cmap='gray')
            plt.xlabel('PMMA')
            plt.xticks([])
            plt.yticks([])
            plt.colorbar(shrink=0.25)
            plt.subplot(132)
            plt.imshow(x_list[i][:,:,1],vmin=vmin[1],vmax=vmax[1], cmap='gray')
            plt.xlabel('Aluminum')
            plt.xticks([])
            plt.yticks([])
            plt.colorbar(shrink=0.25)
            plt.subplot(133)
            plt.imshow(x_list[i][:,:,2],vmin=vmin[2],vmax=vmax[2], cmap='gray')
            plt.xlabel('Gadolinium')
            plt.xticks([])
            plt.yticks([])
            plt.colorbar(shrink=0.25)
            plt.tight_layout()
            if(not(title is None)):
                plt.suptitle(title[i])
                plt.subplots_adjust(top=1.4)
        plt.savefig(filename[i])
        plt.close()


plt.plot(energies,mu_PMMA,label='PMMA')
plt.plot(energies,mu_aluminum,label='aluminum')
plt.plot(energies,mu_gadolinium,label='gadolinium')
plt.legend(loc='upper right')
plt.xlabel('energy (units: keV)')
plt.ylabel('mass attenuation coef. '+r'$\mu/\rho$'+' (units: cm'+r'${}^2$'+'/g)')
plt.yscale('log')
plt.savefig('material_spectra.jpg')
plt.close()


def get_P(ns, nu, nl):
    # create projection matrix
    P = np.zeros((ns,nu,nx,ny))
    pixel_xs = -image_side/2+image_side*np.arange(1+nx)/nx
    pixel_ys = -image_side/2+image_side*np.arange(1+ny)/ny

    for s_ in range(ns):
        for u_ in range(nu):
            # compute length of intersection between pixel x,y and ray s,u
            source_angle = s_*2*np.pi/float(ns)
            source = np.r_[scanner_rad*np.cos(source_angle), scanner_rad*np.sin(source_angle)]
            # coordinates of source location

            detector_angle = source_angle + np.pi - (0.5-0.5/nu)*theta + u_*theta/float(nu)
            detector = np.r_[scanner_rad*np.cos(detector_angle), scanner_rad*np.sin(detector_angle)]
            # coordinates of detector cell location

            t_vals = np.zeros(0)
            if(source[0]!=detector[0]):
                t_vals = np.r_[t_vals, (pixel_xs - source[0])/(detector[0] - source[0])]
            if(source[1]!=detector[1]):
                t_vals = np.r_[t_vals, (pixel_ys - source[1])/(detector[1] - source[1])]
            t_vals = np.sort(np.unique(t_vals))
            t_vals = np.r_[0,t_vals[(0<t_vals) & (t_vals<1)],1]

            length = np.sqrt(((source-detector)**2).sum())

            for it in range(len(t_vals)-1):
                t = (t_vals[it] + t_vals[it+1])/2
                x_coord = (1-t) * source[0] + t * detector[0]
                y_coord = (1-t) * source[1] + t * detector[1]
                if((pixel_xs[0]<=x_coord)&(x_coord<=pixel_xs[nx])&(pixel_ys[0]<=y_coord)&(y_coord<=pixel_ys[ny])):
                    ix = np.argwhere(pixel_xs<=x_coord).max()
                    iy = np.argwhere(pixel_ys<=y_coord).max()
                    P[s_,u_,ix,iy] = P[s_,u_,ix,iy] + length * (t_vals[it+1]-t_vals[it])

    P = P.reshape((nl,nx,ny))
    # check condition number of this P matrix
    Pmat = P.reshape((nl, nx*ny))
    print(f'condition number of Radon matrix is {np.linalg.cond(Pmat)}')
    return P

def Pmult(x, P, nl): # apply projection operator to an image x
    Px = np.zeros((nl,nm))
    for m_ in range(nm):
        Px[:,m_] = (P*x[:,:,m_]).sum((1,2))
    return Px

def Ptmult(y, P): # transpose of the projection operator
    return np.dot(P.transpose((1,2,0)),y)

def get_Psums(P, nl):
    P_rowsums = Pmult(x=np.ones((nx,ny,nm)), P=P, nl=nl)[:,0]
    P_rowsums[P_rowsums<div_by_zero_thresh] = div_by_zero_thresh # avoiding dividing by zero
    P_colsums = Ptmult(y=np.ones((nl,nm)), P=P)[:,:,0]
    P_colsums[P_colsums<div_by_zero_thresh] = div_by_zero_thresh # avoiding dividing by zero
    return P_rowsums, P_colsums


# Approximate exponential, for numerical stability
def qexp(t,deriv=0):
    return np.exp(t*(t<=0))*(t<=0) + \
            (1+t+0.5*t**2)*((t>0)&(deriv==0)) + (1+t)*((t>0)&(deriv==1)) + ((t>0)&(deriv==2))


# Forward model
def get_c_hat_by_energy(y, S, deriv=0):
    # c_hat[w,l,i] = E[# photons in (w,l) at energy i]
    return (S * qexp(-np.dot(y,mu),deriv))

def get_c_hat(y, S, deriv=0):
    # c_hat[w,l] = E[# photons in (w,l), across all energies]
    return get_c_hat_by_energy(y=y, S=S, deriv=deriv).sum(2)

def get_c(x_true, P, nl, S, seed, use_noise):
    if use_noise:
        np.random.seed(seed)
        c = np.random.poisson(get_c_hat(y=Pmult(x=x_true, P=P, nl=nl), S=S)) # generate data
    else:
        c = get_c_hat(y=Pmult(x=x_true, P=P, nl=nl), S=S)
    return c


# Monotone operator
def get_monotone_direction(x, c_star, P, nl, S):
    # x is shape [nx, ny, nm], Pmult(x) is shape [nl, nm]
    assert x.shape[-1] == 1, f'monotone operator only works for single-material models'
    error = c_star - get_c_hat(y=Pmult(x=x, P=P, nl=nl), S=S)  # [nw, nl]
    # Note that we can remove the constant np.sum(mu.flatten()) in the line below, since it is just a scaling factor
    # Doing so would require a corresponding scaling of the step size
    result = np.sum(mu.flatten()) * error @ P.reshape(nl, -1)  # [nw, nx*ny]
    result = result.sum(axis=0).reshape(nx, ny, nm)  # [nx, ny, nm]
    result = result / nl  
    return result


# Gradient descent on MSE loss (L2 error minimization)
def get_L2_direction(x,c,S,P,nl):
    c_hat = get_c_hat(y=Pmult(x=x,P=P,nl=nl), S=S)
    error = c - c_hat  # [nw, nl]
    a = P.reshape(nl, -1)  # [nl, nx*ny]
    expterm = qexp(-np.dot(Pmult(x,P,nl),mu))  # [nl, ni]
    direction = 0
    for w in range(nw):
        for l in range(nl):
            direction = direction + error[w,l] * a[l].reshape(nx*ny,1) @ (expterm[l].reshape(1, ni) @ np.diag(S[w,l,:]) @ mu.T)  # [nx*ny, nm]
    return direction.reshape(nx, ny, nm) / nl


# L1 loss
def get_L1loss(x,c,S,P,nl):
    c_hat = get_c_hat(y=Pmult(x=x,P=P,nl=nl), S=S)  # [nw, nl]
    return np.sum(np.abs(c - c_hat).flatten()) / nl


# Poisson negative log likelihood
def get_loss(x,c,S,P,nl):
    # poisson negative log likelihood, up to a constant term
    #   ( this constant term makes it nonnegative, & ensures that if c = c_hat then loss = 0 )
    c_hat = get_c_hat(y=Pmult(x=x,P=P,nl=nl), S=S)
    if min(c_hat[c>0])<=0:
        return np.inf
    else:
        return (c_hat.sum() - c.sum()) - (c[c>0]*np.log(c_hat[c>0]/c[c>0])).sum()

def get_plot_curves(x_iters, c, S, P, nl, x_true, method='admm'):
    max_iters = len(x_iters)
    if np.min(x_iters) < 0:
        print(f'{method} has negative values in x_iters: {np.min(x_iters)}')
    # choose a subset of the iters to actually evaluate, to speed things up
    iters = np.arange(np.log(max_iters), step=0.01)
    iters = [0] + [int(it) for it in np.exp(iters)] + [max_iters - 1]
    iters = np.unique(iters)
    itersminus1 = np.array([max(0, it-1) for it in iters])
    avgiters = [np.mean(x_iters[int(it/2):it+1], axis=0) for it in iters]
    avgitersminus1 = [np.mean(x_iters[int(it/2):it+1], axis=0) for it in itersminus1]
    # compute the norm difference for each iterate
    normdiff = np.array([np.linalg.norm(avgiters[it] - avgitersminus1[it]) for it in range(len(iters))])
    if method == 'admm':
        loss = np.array([get_loss(x=x,c=c,S=S,P=P,nl=nl) for x in x_iters[iters]])
        avgloss = np.array([get_loss(x=x,c=c,S=S,P=P,nl=nl) for x in avgiters])
    elif method == 'polyaksgm':
        loss = np.array([get_L1loss(x=x,c=c,S=S,P=P,nl=nl) for x in x_iters[iters]])
        avgloss = np.array([get_L1loss(x=x,c=c,S=S,P=P,nl=nl) for x in avgiters])
    elif method == 'monotone' or method == 'extragradient':
        loss = np.array([np.linalg.norm(get_monotone_direction(x=x,c_star=c,P=P,nl=nl,S=S))/nk for x in x_iters[iters]])
        avgloss = np.array([np.linalg.norm(get_monotone_direction(x=x,c_star=c,P=P,nl=nl,S=S))/nk for x in avgiters])
    elif method == 'mse_gd':
        loss = np.array([np.linalg.norm(get_L2_direction(x=x,c=c,P=P,nl=nl,S=S))/nk for x in x_iters[iters]])
        avgloss = np.array([np.linalg.norm(get_L2_direction(x=x,c=c,P=P,nl=nl,S=S))/nk for x in avgiters])
    rmse = np.array([np.sqrt(np.mean((x - x_true)**2)) for x in x_iters[iters]])
    avgrmse = np.array([np.sqrt(np.mean((x - x_true)**2)) for x in avgiters])
    return iters, loss, rmse, normdiff, avgloss, avgrmse
       

################
# TV projection
################


def TV(image):
    grad_x = np.roll(image, -1, axis=1) - image
    grad_y = np.roll(image, -1, axis=0) - image
    return np.sum(np.sqrt(grad_x**2 + grad_y**2))


oracle_tv = TV(x_true)

# https://en.wikipedia.org/wiki/Dykstra%27s_projection_algorithm
# Project onto intersection of two convex constraint sets, 
# in this case the positive orthant and the TV ball
def project_tv_nonnegative(image, max_tv=oracle_tv, w_guess=0.5):
    x = image
    p = 0
    q = 0
    iters = 0
    while True:
        iters = iters + 1
        oldx = x
        y = np.clip(x + p, a_min=0, a_max=None)
        p = x + p - y
        x, w_guess = project_tv(y + q, max_tv=max_tv, w_guess=w_guess)
        q = y + q - x
        if iters % 100 == 0:
            print(f'at iter {iters}: convergence criterion is {np.linalg.norm(x - oldx)}')
        if np.linalg.norm(x - oldx) <= 1e-4:  # was 1e-8, but can be extremely slow to converge
            return x, w_guess


def project_tv(image, max_tv=oracle_tv, w_guess=0.5):
    I = np.copy(image)
    # maxtv=0 is a default to denote no TV projection (unregularized)
    if max_tv == 0:
        return I, w_guess
    # check if the unprojected image already satisfies maxtv
    if TV(I) <= max_tv:
        return I, w_guess
    w = w_guess * 2
    count = 0
    lower = 0
    upper = np.inf
    while True:
        count = count + 1
        I = prox_tv.tv1_2d(x=image, w=w)
        tv = TV(I)
        if count > 100:
            assert False
        if np.abs(tv - max_tv) / max_tv < 0.01:
            return I, w
        if tv > max_tv:
            lower = w
            w = np.min([w * 10, 0.5 * (lower + upper)])
        if tv < max_tv:
            upper = w
            w = 0.5 * (lower + upper)


class RunningAverage:
    def __init__(self):
        self.iterates = []
        self.prefix_sum = [0]  # Prefix sum where prefix_sum[i] stores sum of iterates[0] to iterates[i-1]

    def update(self, x_t):
        self.iterates.append(x_t)
        self.prefix_sum.append(self.prefix_sum[-1] + x_t)

    def replaceprev(self, x_t):
        if len(self.iterates) == 0:
            raise ValueError("No iterates to replace")
        self.prefix_sum[-1] = self.prefix_sum[-1] - self.iterates[-1] + x_t
        self.iterates[-1] = x_t

    def get_xbar(self, t):
        if t > len(self.iterates):
            raise ValueError("t exceeds the number of stored iterates")

        sum_last_half = self.prefix_sum[t] - self.prefix_sum[t // 2]
        return sum_last_half / (t - t // 2)
    
    def get_x(self, t):
        if t > len(self.iterates):
            raise ValueError("t exceeds the number of stored iterates")

        return self.iterates[t]
    

color_dict = {'monotone': 'xkcd:purple', 
              'admm': 'xkcd:orange', 
              'polyaksgm': 'xkcd:green', 
              'extragradient': 'xkcd:blue', 
              'msegd': 'xkcd:dark pink'}
shape_dict = {'monotone': 'P', 
              'admm': 'v',
              'polyaksgm': 'X',
              'extragradient': 'o',
              'msegd': 'D'}